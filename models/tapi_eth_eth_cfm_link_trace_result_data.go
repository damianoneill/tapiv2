// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	strfmt "github.com/go-openapi/strfmt"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/swag"
)

// TapiEthEthCfmLinkTraceResultData tapi eth eth cfm link trace result data
// swagger:model tapi.eth.EthCfmLinkTraceResultData
type TapiEthEthCfmLinkTraceResultData struct {

	// MEF 38:
	//                 The chassis-id-subtype contains the chassis ID entity that is listed in the chassis ID field. This is a combination of the 'Chassis ID Subtype' and 'chsssis ID' fields.
	//                 IEEE P802.1Qcx/D0.3:
	//                 The Chassis ID returned in the Sender ID TLV of the LTR, if any.
	//                 The format of a chassis identifier string. Objects of this type are always used with an associated lldp-chassis-is-subtype object, which identifies the format of the particular lldp-chassis-id object instance.
	//                 If the associated lldp-chassis-id-subtype object has a value of chassis-component, then the octet string identifies a particular instance of the entPhysicalAlias object (defined in IETF RFC 2737) for a chassis component (i.e., an entPhysicalClass value of chassis(3)).
	//                 If the associated lldp-chassis-id-subtype object has a value of interface-alias, then the octet string identifies a particular instance of the ifAlias object (defined in IETF RFC 2863) for an interface on the containing chassis.
	//                 If the particular ifAlias object does not contain any values, another chassis identifier type should be used.
	ChassisID *TapiEthLldpChassisIDSubtype `json:"chassis-id,omitempty"`

	// IEEE P802.1Qcx/D0.3:
	//                 MEF 38:
	//                 An enumerated value indicating the value returned in the Egress Action field.
	//                 IEEE P802.1Qcx/D0.3:
	//                 The value EGRESS-NO-TLV indicates that no Reply Egress TLV was returned in the LTM.
	EgressActionField string `json:"egress-action-field,omitempty"`

	// IEEE P802.1Qcx/D0.3:
	//                 MEF 38:
	//                 MAC address returned in the egress MAC address field.
	//                 IEEE P802.1Qcx/D0.3:
	//                 If the egressActionField contains the value EGRESS-NO-TLV, then the contents of this attribute are meaningless.
	EgressMac string `json:"egress-mac,omitempty"`

	// MEF 38:
	//                 IEEE P802.1Qcx/D0.3:
	//                 Egress Port ID.
	//                 IEEE P802.1Qcx/D0.3:
	//                 If the egressActionField attribute contains the value EGRESS-NO-TLV, then the contents of this attribute are meaningless.
	EgressPortID *TapiEthLldpPortIDSubtype `json:"egress-port-id,omitempty"`

	// IEEE P802.1Qcx/D0.3:
	//                 MEF 38:
	//                 Indicates if a LTM was forwarded by the responding MP, as returned in the FwdYes flag of the flags field.
	Forwarded *bool `json:"forwarded,omitempty"`

	// IEEE P802.1Qcx/D0.3:
	//                 MEF 38:
	//                 The value returned in the Ingress Action Field of the LTM.
	//                 IEEE P802.1Qcx/D0.3:
	//                 The value INGRESS-NO-TLV indicates that no Reply Ingress TLV was returned in the LTM.
	//
	IngressActionField string `json:"ingress-action-field,omitempty"`

	// IEEE P802.1Qcx/D0.3:
	//                 MEF 38:
	//                 MAC address returned in the ingress MAC address field.
	//                 IEEE P802.1Qcx/D0.3:
	//                 If the ingressActionField attribute contains the value INGRESS-NO-TLV, then the contents of this attribute is meaningless.
	IngressMac string `json:"ingress-mac,omitempty"`

	// IEEE P802.1Qcx/D0.3:
	//                 MEF 38:
	//                 Ingress Port ID.
	//                 IEEE P802.1Qcx/D0.3:
	//                 If the ingressActionField attribute contains the value INGRESS-NO-TLV, then the contents of this attribute are meaningless.
	IngressPortID *TapiEthLldpPortIDSubtype `json:"ingress-port-id,omitempty"`

	// IEEE P802.1Qcx/D0.3:
	//                 MEF 38:
	//                 String length '8'
	//                 An octet field holding the Last Egress Identifier returned in the LTR Egress Identifier TLV of the LTR.
	//                 The Last Egress Identifier identifies the MEP Linktrace Initiator that originated, or the Linktrace Responder that forwarded, the LTM to which this LTR is the response.
	//                 This is the same value as the Egress Identifier TLV of that LTM.
	LastEgressIdentifier string `json:"last-egress-identifier,omitempty"`

	// IEEE P802.1Qcx/D0.3:
	//                 MEF 38:
	//                 String length '8'
	//                 An octet field holding the Next Egress Identifier returned in the LTR Egress Identifier TLV of the LTR.
	//                 The Next Egress Identifier Identifies the Linktrace Responder that transmitted this LTR, and can forward the LTM to the next hop.
	//                 This is the same value as the Egress Identifier TLV of the forwarded LTM, if any.
	//                 If the FwdYes bit of the Flags field is false, the contents of this field are undefined, i.e., any value can be transmitted, and the field is ignored by the receiver.
	NextEgressIdentifier string `json:"next-egress-identifier,omitempty"`

	// String length '0 | 4..1500';
	//                 All Organization specific TLVs returned in the LTR, if any. Includes all octets including and following the TLV Length field of each TLV, concatenated together.
	OrganizationSpecificTlv string `json:"organization-specific-tlv,omitempty"`

	// IEEE P802.1Qcx/D0.3:
	//                 MEF 38:
	//                 type uint32 range '1..4294967295'
	//                 An index to distinguish among multiple LTRs with the same LTR Transaction Identifier field value.
	//                 Assigned sequentially from 1, in the order that the Linktrace Initiator received the LTRs.
	ReceiveOrder int32 `json:"receive-order,omitempty"`

	// IEEE P802.1Qcx/D0.3:
	//                 MEF 38:
	//                 An enumerated value indicating the value returned in the Relay Action field.
	//
	RelayActionField string `json:"relay-action-field,omitempty"`

	// IEEE P802.1Qcx/D0.3:
	//                 MEF 38:
	//                 TTL field value for a returned LTR.
	//                 Range '0..255'
	ReplyTTL int32 `json:"reply-ttl,omitempty"`

	// IEEE P802.1Qcx/D0.3:
	//                 type uint32 range '0..4294967295'
	//                 Transaction identifier returned by a previous transmit linktrace message command, indicating which LTMs response is going to be returned.
	//                 MEF 38:
	//                 The LTM Transaction Identifier to which the LTR entries will be attached.
	SeqNumber int32 `json:"seq-number,omitempty"`

	// IEEE P802.1Qcx/D0.3:
	//                 MEF 38:
	//                 A Boolean value stating whether the forwarded LTM reached a MEP enclosing its MA, as returned in the Terminal MEP flag of the Flags field.
	TerminalMep *bool `json:"terminal-mep,omitempty"`
}

// Validate validates this tapi eth eth cfm link trace result data
func (m *TapiEthEthCfmLinkTraceResultData) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateChassisID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEgressPortID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIngressPortID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *TapiEthEthCfmLinkTraceResultData) validateChassisID(formats strfmt.Registry) error {

	if swag.IsZero(m.ChassisID) { // not required
		return nil
	}

	if m.ChassisID != nil {
		if err := m.ChassisID.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("chassis-id")
			}
			return err
		}
	}

	return nil
}

func (m *TapiEthEthCfmLinkTraceResultData) validateEgressPortID(formats strfmt.Registry) error {

	if swag.IsZero(m.EgressPortID) { // not required
		return nil
	}

	if m.EgressPortID != nil {
		if err := m.EgressPortID.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("egress-port-id")
			}
			return err
		}
	}

	return nil
}

func (m *TapiEthEthCfmLinkTraceResultData) validateIngressPortID(formats strfmt.Registry) error {

	if swag.IsZero(m.IngressPortID) { // not required
		return nil
	}

	if m.IngressPortID != nil {
		if err := m.IngressPortID.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ingress-port-id")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *TapiEthEthCfmLinkTraceResultData) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *TapiEthEthCfmLinkTraceResultData) UnmarshalBinary(b []byte) error {
	var res TapiEthEthCfmLinkTraceResultData
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
